# Пояснение к заданию 1. Время выполнения - 6 минут

Необходимо составить запрос, который находит пользователя, чья сумма платежей находится на втором месте после максимальной.

Тут все просто, регулируется это поиском суммы платежей и сорировкой от большого к меньшему, а так как по условию задачи нужно выбрать кто на втором месте - то ставится условие LIMIT
Запрос содержится в файле «Задание 1.txt»

# Пояснение к заданию 2. Время выполнения - 40 минут

Необходимо показать имена и фамилии всех студентов, чей пол до сих не известен (gender = 'unknown') и они сейчас находятся на каникулах (status = ‘vacation’).

По условию второго задания таблица истории статусов студентов содержит условие, где последний по хронологии статус является текущим. Предполагаем что в таком случае и поле datetime идет в хронологическом порядке, поэтому используем запрос указанный в файле «Задание 2.txt»

# Пояснение к заданию 3. Время выполнения - 50 минут

Используя три предыдущие таблицы, найти имена и фамилии всех студентов, которые заплатили не больше трех раз и перестали учиться (status = ‘lost’). Нулевые платежи (amount = 0) не учитывать.

Данный запрос дополняется поиском по третьей таблице с использование конструкции HAVING
Запрос описан в файле «Задание 3.txt»

# Пояснение к заданию 4. Время выполнения - 16 минут

В одном файле хранятся ID пользователей и время их заходов на сайт за 5 лет существования сайта в произвольном порядке. Известно, что существует порядка миллиона пользователей, четверть из которых были активными. Активные пользователи в среднем по 100 раз в день заходили на какую-либо страницу сайта.

Необходимо описать в понятной форме наиболее оптимальный алгоритм создания нового файла, в котором записи из первого файла будут отсортированы по поряду возрастания ID, а для одинаковых ID по хронологии. (Можно написать небольшую программу на PHP, но не обязательно)

Например, если в исходном файле:
	
	1234567890 2013-03-08 12:26:09
	0987654321 2013-03-09 09:23:17
	1234567890 2014-01-01 00:00:34
	0087645544 2015-02-03 17:45:01
  	0087645544 2015-01-03 11:05:06

В результирующем должно быть:
	
	0087645544 2015-01-03 11:05:06
	0087645544 2015-01-03 17:45:01
	0987654321 2013-03-09 09:23:17
	1234567890 2013-03-08 12:26:09
	1234567890 2014-01-01 00:00:34

Реализовать данную задачу можно путем выборки всех данных из базы данных, а дальше записать в массив и производить сортировку алгоритмом быстрой сортировки, сортируя сначала по ID, а в случае совпадения - по дате и времени
